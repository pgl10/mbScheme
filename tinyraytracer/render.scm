
(define (drand48) (rational->real (/ (random 10000) 10000)))

(define PI 3.14159265358979)

(define (ambient-occlusion isect)
  (define ntheta NAO-SAMPLES)
  (define  nphi  NAO-SAMPLES)
  (define eps 0.0001)
  (define p (v+ (isect-p isect) (vscale (isect-n isect) eps)))
  (define basis (orthobasis (isect-n isect)))
  (define occlusion 0.0)
  (define (occ)
    (let ((theta (sqrt (drand48)))
          (phi (* 2 PI (drand48))))
      (let ((x (* (cos phi) theta))
            (y (* (sin phi) theta))
            (z (sqrt (- 1.0 (square theta)))))
        (let ((rx (+ (* x (vx (vector-ref basis 0)))
                     (* y (vx (vector-ref basis 1)))
                     (* z (vx (vector-ref basis 2)))))
              (ry (+ (* x (vy (vector-ref basis 0)))
                     (* y (vy (vector-ref basis 1)))
                     (* z (vy (vector-ref basis 2)))))
              (rz (+ (* x (vz (vector-ref basis 0)))
                     (* y (vz (vector-ref basis 1)))
                     (* z (vz (vector-ref basis 2))))))
          (let ((ray (make-ray p (vec rx ry rz))))
            (let ((occ-isect (make-isect 1.0e+17 (vec 0.0 0.0 0.0) (vec 0.0 0.0 0.0) 0)))
              (set! occ-isect (ray-sphere-intersect occ-isect ray (vector-ref spheres 0)))
              (set! occ-isect (ray-sphere-intersect occ-isect ray (vector-ref spheres 1)))
              (set! occ-isect (ray-sphere-intersect occ-isect ray (vector-ref spheres 2)))
              (set! occ-isect (ray-plane-intersect  occ-isect ray plane))
              (if (not (zero? (isect-hit occ-isect)))
                (set! occlusion (+ occlusion 1)))
            )
          )
        )
      )
    )
  )
  (define (occlu n)
    (if(< n (* ntheta nphi)) (begin (occ) (occlu (+ n 1))))
  ) 
  (occlu 0)
  (set! occlusion (/ (- (* ntheta nphi) occlusion) (* ntheta nphi)))
  (vec occlusion occlusion occlusion)
)

(define (render w h nsubsamples)
  (define (for1 x y u v)
    (let ((px (/ (- (+ x (/ u nsubsamples)) (/ w 2.0)) (/ w 2.0)))
          (py (- (/ (- (+ y (/ v nsubsamples)) (/ h 2.0)) (/ h 2.0)))))
      (let ((ray (make-ray (vec 0.0 0.0 0.0) (vnormalize (vec px py -1.0)))))
        (let ((isect (make-isect 1.0e+17 (vec 0.0 0.0 0.0) (vec 0.0 0.0 0.0) 0)))
          (set! isect (ray-sphere-intersect isect ray (vector-ref spheres 0)))
          (set! isect (ray-sphere-intersect isect ray (vector-ref spheres 1)))
          (set! isect (ray-sphere-intersect isect ray (vector-ref spheres 2)))
          (set! isect (ray-plane-intersect  isect ray plane))
          (if (not (zero? (isect-hit isect)))
          (set! col (v+ col (ambient-occlusion isect))))
        )
      )
    )
  )
  (define (foru x y u v)
    (if (< u nsubsamples) (begin (for1 x y u v) (foru x y (+ u 1) v)))
  )
  (define (forv x y u v)
    (if (< v nsubsamples) (begin (foru x y 0 v) (forv x y 0 (+ v 1))))
    (vector-set! img (+ (* 3 (+ (* y w) x)) 0) (clamp (/ (vx col) (square nsubsamples))))
    (vector-set! img (+ (* 3 (+ (* y w) x)) 1) (clamp (/ (vy col) (square nsubsamples))))
    (vector-set! img (+ (* 3 (+ (* y w) x)) 2) (clamp (/ (vz col) (square nsubsamples))))
  ) 
  (define (forx x y u v)
    (set! col (vec 0.0 0.0 0.0))
    (if (< x w) (begin (forv x y 0 0) (forx (+ x 1) y 0 0)))
  )
  (define (fory x y u v)
    (if (< y h) (begin (forx 0 y 0 0) (fory 0 (+ y 1) 0 0)))
  )
  (define img (make-vector (* w h 3)))
  (define col (vec 0.0 0.0 0.0))
  (fory 0 0 0 0)
  img
)
